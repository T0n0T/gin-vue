每次系统重启重置token
成功登录后，frontend询问backend数据库
1.设备记录表，对于每条查询到的设备，显示在界面上，并重新进行设备创建过程，最终显示设备的可用与否，不可用要有状态查看的方式，可用则使用对应的存储数据来配置设备
2.连接记录表，从成功创建的设备的devid查询连接，对于每条存在的连接，查询连接是否可用，如果不可用还需要使用对应的存储数据创建连接，并再次检查，如果再不可用应该有异常，重试标志
3.路由记录表，对于每条查询到的路由，显示在界面上，并查找devid是否正常，然后查找connid是否正常，如果任意项异常，需要显示并给出重试机制

设备管理器类（DeviceManager）应该具有自己的缓存以及自身的deviceType，用于记录设备管理器中有多少设备以及设备类型，它会被每个无线配置页面实例化，实例化时应该传入devID生成函数DeviceIdentify，connID生成函数ConnectIdentify，拥有DeviceCreate，DeviceDestroy，DeviceCheck，DeviceConnectCreate，DeviceConnectDestroy，DeviceConnectCheck的方法，调用api/device.js中的同名api；
设备（Device）被设备管理器实例化，包含设备的标识devID和status，并持有供调用者识别设备的deviceHandle和存储配置的deviceConfig，以及属于设备的连接connectmap；
proto的序列化反序列化方法都在proto/wireless.js中；
连接（Connect）被设备管理器实例化，应该包含status，connID，connHandle；
设备管理器DeviceCreate过程：
1.传入deviceData；
2.使用deviceData创建proto序列化的DeviceCreateContext；
3.使用DeviceCreateContext作为参数，异步调用api层对应的DeviceCreate；
4.成功执行DeviceCreate后，使用DeviceIdentify从deviceData生成devID，并使用devID创建设备实例，并使用status位inactive表示设备未激活，设备实例记录在pinia中；
设备管理器DeviceDestroy过程：
1.传入devID；
2.异步调用api层对应的DeviceDestroy；
3.调用成功后在pinia中移除devID对应设备；
设备管理器DeviceCheck过程：
1.异步调用api层DeviceCheck，返回值使用proto解析，得到多组devID和DeviceHandle；
2.对于每一组数据，根据devID查询pinia中的设备，标注设备为active；
3.如果是未在pinia中找到设备，则在pinia中使用devID和创建设备实例，并直接标记为active；
设备管理器DeviceConnectCreate创建设备连接过程：
1.传入devID，connectData；
2.使用传入参数创建proto序列化的ConnectCreateContext；
3.使用ConnectCreateContext，异步调用api层对应的DeviceConnectCreate；
4.调用成功后，使用ConnectIdentify从connectData生成connid，并用来创建connect，connect的status标记为unavailable，connect键值对存入devID对应的device变量的connectmap中；
设备管理器DeviceConnectDestroy创建设备连接过程：
1.传入devID，connID；
2.使用传入参数创建proto序列化的ConnectDestroyContext；
3.使用ConnectDestroyContext异步调用api层对应的DeviceConnectDestroy；
4.调用成功后，从device变量的connectmap中删除对应connID的键值对
设备管理器DeviceConnectCheck创建设备连接过程：
1.传入devID；
2.使用传入参数创建proto序列化的DeviceID；
3.使用DeviceID异步调用api层对应的DeviceConnectCheck，返回值通过proto解析，得到多组connID和连接对应的available值，用于标记连接的connSpec数据；
4.对于每组数据，在devID对应的device变量connectmap中查找connID，如过找到则修改其available值为proto解析值，如果找不到，则在connectmap中使用connID和传入的available值，connSpec增加实例；
请在devMngr.js中实现上面提到的

路径（Entry）应该包含number类型的devID，connID，refChannelUp，refChannelDown；
通道（channel）应该包含topic，区分上行下行的channeltype，number类型的channID，EntryID；
路由（router）应该包含name，并拥有一个上行channel的chanID和一个下行channel的chanID；
路由管理器（routerManager）应该具有自己的pinia缓存，缓存包括了router类的map，上行通道map和下行通道map，以及连接抽象Entry的map，在路由配置界面初始化时它会在路由配置页面实例化一次；
路由管理器RouterCreate过程：
1.传入路由主题topic，路由名字name，上行连接的devID，connID，下行连接的devID，connID；
2.使用name创建router实例；
3.拼接上行连接的devID和connID作为键值EntryID，查找上行Entry，如果Entry不存在则创建它，并缓存到routerManager的pinia；
4.查看Entry的refChannelUp，如果为0则创建上行channel，否则跳过上行channel的创建直接跳到12；

5.创建上行channel，使用topic和通道类型up创建proto序列化的ChannelCreateContext；
6.使用ChannelCreateContext异步调用api层ChannelCreate，创建上行channel；
7.成功调用后，使用proto解析返回值，得到chanID；
8.使用chanID，上行连接devID，connID，创建proto序列化的ChannelBindContext；
9.使用ChannelBindContext异步调用api层ChannelBind，为上行channel绑定上行连接；
10.成功调用后，使用chanID、EntryID创建上行通道channel实例，并存储到pinia中；
11.将chanID放入上行Entry的refChannelUp中

12.将创建的上行通道chanID，或已存在的上行通道channel的chanID（也就是Entry的reChannelUP），赋给router的上行chanID；

13.拼接下行连接的devID和connID作为键值EntryID，查找下行Entry，如果Entry不存在则创建它，并缓存到routerManager的pinia；
14.查看Entry的refChannelDown数组，
14.使用topic和通道类型down创建proto序列化的ChannelCreateContext；
14.使用ChannelCreateContext异步调用api层ChannelCreate，创建下行channel；
15.成功调用后，使用proto解析返回值，得到chanID；
16.使用chanID，下行连接的devID，connID，创建proto序列化的ChannelBindContext；
17.使用ChannelBindContext异步调用api层ChannelBind，为下行channel绑定下行连接；
18.成功调用后，使用chanID、devID，connID创建下行通道channel实例，并存储到pinia中；
19.将创建的下行通道channel实例，在router的下行channel中引用；
20.把router实例添加到pinia中；

路由管理器RouterDestroy过程：
1.传入路由名称name；
2.使用name查找pinia中的router实例；
3.使用router实例的下行chanID创建proto序列化的ChannelID消息；
4.使用ChannelID异步调用api层ChannelDestroy，销毁下行通道；
5.如过已经不存在下行通道，则需要进行6,7把上行通道也销毁，否则跳过6,7；
6.使用router实例的上行chanID创建proto序列化的ChannelID消息；
7.使用ChannelID异步调用api层ChannelDestroy，销毁上行通道；
8.上下行通道处理完毕后，从routerManager的pinia中移除name对应的router实例；
路由管理器RouterEnable过程：
1.传入name；
2.使用name查找pinia中的router实例；
3.使用router实例的chanID创建proto序列化的ChannelID消息；
4.使用ChannelID异步调用api层ChannelEnable；
5.成功调用后，从routerManager的pinia中移除name对应的router实例；
路由管理器RouterDisable过程：
1.传入name；
2.使用name查找pinia中的router实例；
3.使用router实例的chanID创建proto序列化的ChannelID消息；
4.使用ChannelID异步调用api层ChannelDisable；
5.成功调用后，从routerManager的pinia中移除name对应的router实例；
