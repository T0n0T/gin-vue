每次系统重启重置token
成功登录后，frontend询问backend数据库
1.设备记录表，对于每条查询到的设备，显示在界面上，并重新进行设备创建过程，最终显示设备的可用与否，不可用要有状态查看的方式，可用则使用对应的存储数据来配置设备
2.连接记录表，从成功创建的设备的devid查询连接，对于每条存在的连接，查询连接是否可用，如果不可用还需要使用对应的存储数据创建连接，并再次检查，如果再不可用应该有异常，重试标志
3.路由记录表，对于每条查询到的路由，显示在界面上，并查找devid是否正常，然后查找connid是否正常，如果任意项异常，需要显示并给出重试机制

设备管理器类（DeviceManager）应该具有自己的缓存以及自身的deviceType，用于记录设备管理器中有多少设备以及设备类型，它会被每个无线配置页面实例化，实例化时应该传入devID生成函数DeviceIdentify，connID生成函数ConnectIdentify，拥有DeviceCreate，DeviceDestroy，DeviceCheck，DeviceConnectCreate，DeviceConnectDestroy，DeviceConnectCheck的方法，调用api/device.js中的同名api；
设备（Device）被设备管理器实例化，包含设备的标识devID和status，并持有供调用者识别设备的deviceHandle和存储配置的deviceConfig，以及属于设备的连接connectmap；
proto的序列化反序列化方法都在proto/wireless.js中；
连接（Connect）被设备管理器实例化，应该包含status，connID，connHandle；
设备管理器DeviceCreate过程：
1.传入deviceData；
2.使用deviceData创建proto序列化的DeviceCreateContext；
3.使用DeviceCreateContext作为参数，异步调用api层对应的DeviceCreate；
4.成功执行DeviceCreate后，使用DeviceIdentify从deviceData生成devID，并使用devID创建设备实例，并使用status位inactive表示设备未激活，设备实例记录在pinia中；
设备管理器DeviceDestroy过程：
1.传入devID；
2.异步调用api层对应的DeviceDestroy；
3.调用成功后在pinia中移除devID对应设备；
设备管理器DeviceCheck过程：
1.异步调用api层DeviceCheck，返回值使用proto解析，得到多组devID和DeviceHandle；
2.对于每一组数据，根据devID查询pinia中的设备，标注设备为active；
3.如果是未在pinia中找到设备，则在pinia中使用devID和创建设备实例，并直接标记为active；
设备管理器DeviceConnectCreate创建设备连接过程：
1.传入devID，connectData；
2.使用传入参数创建proto序列化的ConnectCreateContext；
3.使用ConnectCreateContext，异步调用api层对应的DeviceConnectCreate；
4.调用成功后，使用ConnectIdentify从connectData生成connid，并用来创建connect，connect的status标记为unavailable，connect键值对存入devID对应的device变量的connectmap中；
设备管理器DeviceConnectDestroy创建设备连接过程：
1.传入devID，connID；
2.使用传入参数创建proto序列化的ConnectDestroyContext；
3.使用ConnectDestroyContext异步调用api层对应的DeviceConnectDestroy；
4.调用成功后，从device变量的connectmap中删除对应connID的键值对
设备管理器DeviceConnectCheck创建设备连接过程：
1.传入devID，
2.使用传入参数创建proto序列化的DeviceID；
3.使用DeviceID异步调用api层对应的DeviceConnectCheck，返回值通过proto解析，得到多组connID和连接对应的available值，用于标记连接的connSpec数据；
4.对于每组数据，在devID对应的device变量connectmap中查找connID，如过找到则修改其available值为proto解析值，如果找不到，则在connectmap中使用connID和传入的available值，connSpec增加实例；
请在devMngr.js中实现上面提到的

路由（router）应该包含topic，上行channel和下行channelmap；
通道（channel）应该包含number类型的channID，devID，connID；
路由管理器（routerManager）应该具有自己的缓存，用于记录router类的map，它会在路由配置页面实例化一次；
路由管理器RouterCreate过程：
1.传入路由主题topic，路由名字name，上行连接的devID，connID，下行连接的devID，connID；
2.使用topic，name创建router实例；
3.先创建上行通道，使用topic和通道类型up创建proto序列化的ChannelCreateContext；
4.使用ChannelCreateContext异步调用api层ChannelCreate；
5.成功调用后，使用proto解析返回值，得到chanID；
6.使用chanID，devID，connID，创建proto序列化的ChannelBindContext；
7.使用ChannelBindContext异步调用api层ChannelBind；
8.成功调用后，使用chanID、devID，connID创建上行通道channel实例，赋值给router的上行channel中;
9.类似2、3、4、5、6、7、8创建下行通道实例并绑定，加入到router下行channel的map中；
10.把router实例添加到pinia中
路由管理器RouterDestroy过程：
